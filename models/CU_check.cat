(* Check for executions which exhibit ConstrainedUnpredictable behaviour (WIP) *)

(* could-fetch-from *)
(* [W]; cff; [IF] iff
 *  the write and IF are to the same location
 *  the W is not ordered after the IF
 *  and there is no instruction synchronisation sequence between them
 *)
cff = ([W]; loc; [IF]) \ ob^-1 \ (isyncob^-1; ob)

(* cmodx(IF) is True if the opcode fetched is in the list of concurrenty modifiable instructions *)
define cmodx(ev1: Event): bool =
    IF(ev1) (* TODO: check for Unconditional Branches *)

(* cff_bad(W1, IF, W2) if IF could have fetched from either (W1, W2)
 * and one of the pair (W1, W2) is not a concurrently modifiable instruction
 *)
define cff_bad(ev1: Event, ev2: Event, ev3: Event): bool =
    W(ev1) & IF(ev2) & W(ev3)
    & ~(ev1 = ev3)
    & cff(ev1, ev2) & cff(ev3, ev2)
    & ~cmodx(ev2)

(* ideally this would be a flag (in the made-up herd-like syntax at the bottom)
 *
 * instead, this asserts that there *is* a bad could-fetch-from.
 * to check, take an execution which results in a satisfiable outcome
 * and add this assertion.
 *
 * if the execution is still satisfiable, then it exhibited constrained unpredictable behaviour
 * and the entire test should be flagged as such.
 *)
assert exists ev1: Event, ev2: Event, ev3: Event =>
    cff_bad(ev1, ev2, ev3)

(* flag empty cff_bad as CU *)
(* Coherence-Order *)
declare co(Event, Event): bool

(* co has domain and range of W *)
assert forall ev1: Event, ev2: Event =>
    wco(ev1, ev2) -->
    (W(ev1) | (ev1 == IW)) & W(ev2)

(* co is transitive *)
assert forall ev1: Event, ev2: Event, ev3: Event =>
    co(ev1, ev2) & co(ev2, ev3) --> co(ev1, ev3)

(* co is total *)
assert forall ev1: Event, ev2: Event, ev3: Event =>
    co(ev1, ev3) & co(ev2, ev3) & ~(ev1 == ev2) -->
    co(ev1, ev2) | co(ev2, ev1)

(* co is irreflexive *)
assert forall ev1: Event, ev2: Event, ev3: Event =>
    co(ev1, ev2) --> ~(ev1 == ev2)

(* co is antisymmetric *)
assert forall ev1: Event, ev2: Event =>
    co(ev1, ev2) --> ~co(ev2, ev1)

(* all same-location pairs of writes are co related *)
assert forall ev1: Event, ev2: Event =>
    W(ev1) & W(ev2) & loc(ev1, ev2) -->
    co(ev1, ev2) | co(ev2, ev1)

(* Reads-From *)
declare rf(Event, Event): bool

(* A read can only read from a single event *)
assert forall ev1: Event, ev2: Event, ev3: Event =>
    rf(ev1, ev2) & rf(ev3, ev2) --> (ev1 == ev3)

(* Reads are paired with writes *)
assert forall ev1: Event, ev2: Event =>
    rf(ev1, ev2) -->
    ((W(ev1) & loc(ev1, ev2) & rw-pair(ev1, ev2))
    |(ev1 == IW) & r-initial(ev2))

(* All reads read from somewhere *)
assert forall ev1: Event =>
    R(ev1) --> exists ev2: Event => rf(ev1, ev2)
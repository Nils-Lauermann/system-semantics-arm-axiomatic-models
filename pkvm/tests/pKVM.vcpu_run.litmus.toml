arch = "AArch64"
name = "pKVM.vcpu_run"
symbolic = []

page_table_setup = """
option default_tables = false;

virtual x;
physical pa1 pa2;
intermediate ipa1 ipa2;

s1table host_stage1 0x2C0000 {
  x |-> ipa1;
}
s1table guest1_stage1 0x300000 {
  x |-> ipa2;
}
s2table host_stage2 0x240000 {
  ipa1 |-> pa1;
  s1table host_stage1;
}
s2table guest1_stage2 0x280000 {
  ipa2 |-> pa2;
  s1table guest1_stage1;
}
s1table hyp_map 0x200000 {
  identity 0x1000 with code;
  identity 0x2000 with code;
  x |-> invalid;
  s2table host_stage2;
  s2table guest1_stage2;
}
*pa1 = 1;
*pa2 = 2;
"""

[thread.0]
code = """
  // in host
  // read x (= pa1 = 1)
  MOV X0,#0
  LDR X0,[X1]
  // __kvm_vcpu_run  (switch to guest1)
  HVC #0x0
  // in guest
  // read x (= pa2 = 2)
  MOV X2,#0
  LDR X2,[X3]
"""

[section.thread0_el2_handler_lower_exc]
address = "0x2400" # 0x400 - Lower Exception Level
code = """
  MRS X11,ESR_EL2
  UBFX X11, X11, #26, #5
  SUBS X12, X12, 0b010110
  CBZ X12, hvc_handler
dabt_handler:
  MRS X20,ELR_EL2
  ADD X20,X20,#4
  MSR ELR_EL2,X20
  ERET
hvc_handler:
  // nvhe/switch.c:299 __sysreg_restore_state_nvhe(guest_ctxt);
  // nvhe/sysreg-sr.c:31 __sysreg_restore_el1_state(ctxt);
  // sysreg-sr.h:118 write_sysreg_el1(ctxt_sys_reg(ctxt, TTBR0_EL1),	SYS_TTBR0);
  MSR TTBR0_EL1, X4
  // nvhe/switch.c:302 __load_stage2(mmu, kern_hyp_va(mmu->arch));
  // kvm_mmu.h:290 write_sysreg(kvm_get_vttbr(mmu), vttbr_el2);
  MSR VTTBR_EL2, X5
  // hyp/entry.S:83
  ERET
"""

[thread.0.reset]
R1 = "x"
R3 = "x"
R4 = "ttbr(asid=0x00, base=guest1_stage1)"
R5 = "ttbr(vmid=0x0002, base=guest1_stage2)"
TTBR0_EL2 = "ttbr(asid=0x00, base=hyp_map)"
VTTBR_EL2 = "ttbr(vmid=0x0001, base=host_stage2)"
TTBR0_EL1 = "ttbr(asid=0x00, base=host_stage1)"
VBAR_EL2 = "extz(0x2000, 64)"

"PSTATE.EL" = "0b01"
"PSTATE.SP" = "0b1"

[final]
assertion = "0:X0=1 & ~0:X2=2"